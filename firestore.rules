/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. Users have full control over their own profile and associated data, such as messages. Access to shared data, like a message, is granted only to the participants (sender and recipient). Publicly readable data is explicitly segregated into its own collections.
 *
 * Data Structure: User data is stored under a user-specific path `/users/{userId}`. This includes subcollections like `/messages`. Top-level collections like `/vip_subscriptions` and `/roles_verified` store application-wide data that is either owner-specific or public.
 *
 * Key Security Decisions:
 * - User Listing Disabled: It is not possible to query the list of all users in the system.
 * - Backend-Managed Collections: Collections like `/vip_subscriptions` and `/roles_verified` are not writable by clients. They are intended to be managed by a trusted backend service (e.g., Cloud Functions) to handle payments, promotions, or administrative tasks. This is a critical security pattern.
 * - Secure Message Access: Access to messages is controlled by checking the `senderId` and `recipientId` fields denormalized onto the message document itself. A user can only access messages where they are a participant and only through their own user-specific collection path.
 *
 * Denormalization for Authorization: To ensure fast and secure access, authorization data is denormalized. For example, `vip_subscriptions` documents contain a `userId` field, and `message` documents contain `senderId` and `recipientId` fields. This avoids costly and slow `get()` calls to other documents during rule evaluation.
 *
 * Structural Segregation: Public data, like the list of verified users, is stored in a separate top-level collection (`/roles_verified`) rather than as a flag on the user object. This allows for safe public list queries without exposing private user information.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for concise and readable rules
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the incoming data for a new User profile document is valid.
     * @principle Ensures the user document's internal ID matches the document path,
     *            establishing a consistent ownership link.
     */
    function hasValidNewUserData() {
      return request.resource.data.id == request.auth.uid;
    }
    
    /**
     * @description Enforces immutability of critical user identity fields on update.
     */
    function hasImmutableUserData() {
        return request.resource.data.id == resource.data.id;
    }
    
    /**
     * @description Checks if the authenticated user is a participant in a message.
     */
    function isMessageParticipant(message) {
        return request.auth.uid == message.senderId || request.auth.uid == message.recipientId;
    }

    /**
     * @description Validates a new message being created.
     * @principle Prevents spoofing by ensuring the sender is the authenticated user.
     *            Also ensures the message is being created in the sender's own subcollection.
     */
    function isValidNewMessage(userId) {
      let isSender = request.auth.uid == request.resource.data.senderId;
      let inSenderPath = userId == request.resource.data.senderId;
      return isSender && inSenderPath;
    }

    /**
     * @description Enforces immutability for core message fields on update.
     * @principle Prevents a user from altering who sent a message or who it was sent to
     *            after it has been created.
     */
    function hasImmutableMessageFields() {
        let incoming = request.resource.data;
        let existing = resource.data;
        return incoming.senderId == existing.senderId && incoming.recipientId == existing.recipientId;
    }


    /**
     * @description User profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user 'user123' can create their own profile at '/users/user123'.
     * @deny (get) User 'user456' cannot read the profile document at '/users/user123'.
     * @deny (list) No user can list all documents in the '/users' collection.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidNewUserData();
      allow update: if isExistingOwner(userId) && hasImmutableUserData();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Messages subcollection for a user. A user can list messages in their
       *              own subcollection, and can read/write a message if they are a participant.
       * @path /users/{userId}/messages/{messageId}
       * @allow (list) User 'user123' can list all messages under '/users/user123/messages'.
       * @allow (get) User 'user456' (recipient) can read a message at '/users/user123/messages/{msgId}'
       *            if they are listed as the recipient in the document.
       * @deny (create) User 'user123' cannot create a message in their collection where the senderId is 'user456'.
       * @principle Enforces document ownership for writes and participant-based access for reads.
       */
      match /messages/{messageId} {
        allow get: if isOwner(userId) && resource != null && isMessageParticipant(resource.data);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && isValidNewMessage(userId);
        allow update: if isExistingOwner(userId) && isMessageParticipant(resource.data) && hasImmutableMessageFields();
        allow delete: if isExistingOwner(userId) && isMessageParticipant(resource.data);
      }
    }

    /**
     * @description Stores VIP subscription details. Only the user who owns the subscription can read it.
     *              This collection is managed by a backend process, not clients.
     * @path /vip_subscriptions/{vipSubscriptionId}
     * @allow (get) A user can read their own subscription document if its 'userId' field matches their UID.
     * @deny (list) No user can list all subscriptions in the system.
     * @deny (create) A user cannot create their own subscription document.
     * @principle Secures sensitive data by restricting reads to the owner and disallowing all client-side writes.
     */
    match /vip_subscriptions/{vipSubscriptionId} {
      allow get: if isSignedIn() && resource != null && isOwner(resource.data.userId);
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description A public, read-only collection to identify verified users. The existence of a
     *              document indicates the user is verified.
     * @path /roles_verified/{userId}
     * @allow (get, list) Any user, signed in or not, can check if a user is verified.
     * @deny (create, update, delete) No client can modify this collection; it is managed by a backend admin process.
     * @principle Provides public read-only access for status information while preventing tampering.
     */
    match /roles_verified/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}