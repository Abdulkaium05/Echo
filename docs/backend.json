{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the ConnectVIP application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user entity."
        },
        "username": {
          "type": "string",
          "description": "User's display name."
        },
        "email": {
          "type": "string",
          "description": "User's email address.",
          "format": "email"
        },
        "profilePictureUrl": {
          "type": "string",
          "description": "URL of the user's profile picture.",
          "format": "uri"
        },
        "isVerified": {
          "type": "boolean",
          "description": "Indicates if the user is a verified user."
        }
      },
      "required": [
        "id",
        "username",
        "email"
      ]
    },
    "Subscription": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Subscription",
      "type": "object",
      "description": "Represents a user's VIP subscription.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the subscription entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User. (Relationship: User 1:N Subscription)"
        },
        "startDate": {
          "type": "string",
          "description": "Start date of the subscription.",
          "format": "date-time"
        },
        "endDate": {
          "type": "string",
          "description": "End date of the subscription.",
          "format": "date-time"
        },
        "price": {
          "type": "number",
          "description": "The price for this subscription."
        }
      },
      "required": [
        "id",
        "userId",
        "startDate",
        "endDate",
        "price"
      ]
    },
    "Message": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Message",
      "type": "object",
      "description": "Represents a message sent between users.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the message entity."
        },
        "senderId": {
          "type": "string",
          "description": "Reference to the User who sent the message. (Relationship: User 1:N Message as Sender)"
        },
        "receiverId": {
          "type": "string",
          "description": "Reference to the User who received the message. (Relationship: User 1:N Message as Receiver)"
        },
        "content": {
          "type": "string",
          "description": "Content of the message."
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the message was sent.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "senderId",
        "receiverId",
        "content",
        "timestamp"
      ]
    },
    "Gift": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Gift",
      "type": "object",
      "description": "Represents a gift sent from one user to another.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the gift."
        },
        "senderId": {
          "type": "string",
          "description": "The UID of the user who sent the gift."
        },
        "receiverId": {
          "type": "string",
          "description": "The UID of the user who received the gift."
        },
        "giftType": {
          "type": "string",
          "enum": [
            "badge",
            "points"
          ]
        },
        "badgeType": {
          "type": "string",
          "description": "The type of badge, if the gift was a badge."
        },
        "pointsAmount": {
          "type": "number",
          "description": "The amount of points, if the gift was points."
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When the gift was sent."
        }
      },
      "required": [
        "id",
        "senderId",
        "receiverId",
        "giftType",
        "timestamp"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. Access is restricted to the user themselves.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/subscriptions/{subscriptionId}",
        "definition": {
          "entityName": "Subscription",
          "schema": {
            "$ref": "#/backend/entities/Subscription"
          },
          "description": "Stores subscriptions for a user. Access is restricted to the user themselves.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "subscriptionId",
              "description": "The unique identifier of the subscription."
            }
          ]
        }
      },
      {
        "path": "/messages/{messageId}",
        "definition": {
          "entityName": "Message",
          "schema": {
            "$ref": "#/backend/entities/Message"
          },
          "description": "Stores messages between users. Access is granted to the sender and receiver, based on the `senderId` and `receiverId` fields.",
          "params": [
            {
              "name": "messageId",
              "description": "The unique identifier of the message."
            }
          ]
        }
      },
      {
        "path": "/verified_users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores IDs of verified users. The existence of a document indicates the user is verified. Access is restricted to admins.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the verified user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/gifts/{giftId}",
        "definition": {
          "entityName": "Gift",
          "schema": {
            "$ref": "#/backend/entities/Gift"
          },
          "description": "Stores gift history for a user. A user can read their own gifts. Any signed-in user can create a gift for another user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user receiving the gift."
            },
            {
              "name": "giftId",
              "description": "The unique identifier of the gift."
            }
          ]
        }
      }
    ],
    "reasoning": "This Firestore structure prioritizes authorization independence and clarity for the ConnectVIP application, focusing on secure messaging and subscription management. It leverages path-based ownership for user data and denormalization for collaborative data access.\n\n*   **Users (Private Data):** User profiles are stored under `/users/{userId}`. This structure provides a clear ownership model. No denormalization is needed because access is based solely on `request.auth.uid == userId`.\n*   **Subscriptions (User-Owned Data):** Subscriptions are stored as subcollections under `/users/{userId}/subscriptions/{subscriptionId}`. This continues the path-based ownership, ensuring that only the user can manage their subscriptions.  No denormalization is needed because access is based solely on `request.auth.uid == userId`.\n*   **Messages (Collaborative Data):** Messages are stored in a `/messages` collection.  Each message includes `senderId` and `receiverId`. Security rules will enforce that only the sender or receiver can read the message. While it might be tempting to create subcollections under users, flattening into a single `messages` collection avoids complex fan-out writes when a user has a large number of messages and simplifies queries.\n*   **Verified Users (Global Roles):**  A dedicated collection `/verified_users/{userId}` stores IDs of verified users. The *existence* of a document in this collection grants verified status.  This is much better than storing a `verified` boolean in the user document since it allows admins to easily manage the status without modifying the user document itself. Security rules will check for the existence of this document to grant access to VIP features.\n\n**Authorization Independence (CRITICAL):**  All authorization checks rely on `request.auth.uid` and data within the document being accessed.  There are NO `get()` calls to parent documents to determine access.  The membership map pattern in messages ensures users can only read messages they are a part of without needing to check user roles.\n\n**QAPs Support:**\n*   Secure List operations are enabled because collections are segregated based on access needs.  Listing users, for example, does not require filtering based on roles.\n*   The existence check pattern used for `/verified_users` allows for secure `list` operations. Admins can list verified users, and the rules will ensure that only admins have read access to this collection."
  }
}
    